{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Modeling and Simulation of Vertex Models in C++","text":"<p>Welcome to the documentation of vertex models in computational biology.</p>"},{"location":"#chapter-1-introduction-to-vertex-models","title":"Chapter 1: Introduction to Vertex Models","text":"<p>The chapter gives a brief introduction to vertex models for cell alignment.</p>"},{"location":"#chapter-2-basics-of-c","title":"Chapter 2: Basics of C++","text":"<p>Here we introduce you to Object Oriented Programming in C++ required for understanding the implementation of this project.</p>"},{"location":"chapter1/","title":"Simulation of a Vertex Model of cells","text":"<p>Vertex model simulations using C++ involves modeling the mechanical interactions between cells and their vertices.</p>"},{"location":"chapter1/#vertex-model","title":"Vertex Model","text":"<p>Active Vertex Model (AVM) is a computational approach used to simulate the mechanical behavior of cells in a tissue. Cells are represented as polygons (typically in 2D), with vertices that can move. Vertices are connected by edges, defining the cell boundaries. The system evolves by minimizing an energy function, which includes terms for cell area, perimeter, and other properties.  </p>"},{"location":"chapter1/#cell-polarity","title":"Cell Polarity","text":"<p>Cell polarity refers to the intrinsic asymmetry observed in cells, either in their shape, structure or organization of cellular components. It is involved in almost all physiological and developmental processes.</p> <p>First, we will focus on modelling cell alignment. Here are a few annotations about collective motion that seem interesting:   </p> <p>\u201cTo the physicist, they are also highly nontrivial because they occur without any leader, external field, or geometrical constraint: collective motion can then be seen as the long-range orientational order following spontaneous symmetry-breaking.\u201d (Chat\u00e9 et al., 2008, p. 451) (pdf)</p> <p>\u201cMedical doctors try to understand tumor growth or wound healing, two situations in which cells move collectively.\u201d (Chat\u00e9 et al., 2008, p. 451) (pdf)</p> <p>\u201cIt is only recently (say fifteen years ago) that physicists, in their usual abrupt manner, approached the problem of collective motion by stripping it down to simple experiments or models having in mind the spontaneous symmetry-breaking picture mentioned above.\u201d (Chat\u00e9 et al., 2008, p. 451) (pdf)</p> <p>\u201c\u201cVicsek model\u201d (VM)\u2014 is central because of its \u201cminimal\u201d character. In short, in the VM, point particles move at fixed velocity, align locally with neighbors, while being submitted to some noise. In other words, an XY model in which the spins are actively moving.\u201d (Chat\u00e9 et al., 2008, p. 451) (pdf)</p> <p>\u201cwe argue that the focal nature of the VM calls for it being extended, expanded, along three main directions in order to account for most of the different types of collective motion listed above. These are \u2013 to vary the polarity of the particles and of their interaction \u2013 to introduce a attraction/repulsion pairwise interaction to allow for cohesion \u2013 to take into account the ambient fluid in which the particles move\u201d (Chat\u00e9 et al., 2008, p. 451) (pdf)</p> <p>\u201cThe two main parameters of the VM are \u03c1, the density of particles, and \u03b7, the noise strength. At zero noise, perfect alignment eventually settles in the whole system (at least if the particles evolve in a domain with periodic \u201cboundary conditions). At maximum noise (\u03b7 =1),particles are just non-interacting random walkers. Thus, a transition must occur in between.\u201d \u201d (Chat\u00e9 et al., 2008, p. 452) (pdf)</p> <p>\u201cVicsek-style models can also be constructed in which the symmetry of the particles differ from that of their interactions.\u201d (Chat\u00e9 et al., 2008, p. 453) (pdf)</p> <p>\u201cIndeed, when thinking, say, of shaken elongated polar granular particles, it is likely that their inelastic collisions are rather nematic than purely polar: when colliding almost head-on, they will glide along each other rather than align.\u201d (Chat\u00e9 et al., 2008, p. 453) (pdf) </p>"},{"location":"chapter1/#references","title":"References","text":"<p>Barton, D. L., Henkes, S., Weijer, C. J., &amp; Sknepnek, R. (2017). Active vertex model for cell-resolution description of epithelial tissue mechanics. PLOS Computational Biology, 13(6). https://doi.org/10.1371/journal.pcbi.1005569 </p> <p>Fletcher, A. G., Osterfield, M., Baker, R. E., &amp; Shvartsman, S. Y. (2014). Vertex models of epithelial morphogenesis. Biophysical journal, 106(11), 2291\u20132304. https://doi.org/10.1016/j.bpj.2013.11.4498</p>"},{"location":"chapter2/","title":"Concepts of C++ for this project!","text":""},{"location":"chapter2/#object-oriented-programming-c-class","title":"Object Oriented Programming - C++ Class","text":"<p>A C++ class is a blueprint for creating objects. It encapsulates data for the object and methods to manipulate that data. Classes define the properties (data members) and behaviors (member functions or methods) that the objects created from the class can have.</p>"},{"location":"chapter2/#c-vector","title":"C++ vector","text":"<p>Vector is used to store the elements dynamically. In C++, a vector is similar to dynamic arrays with the ability to resize itself automatically.</p> <p>In the case of a static array, we cannot insert elements once it is full but when the size of a vector becomes full then it doubles its size from the original. That's why it is beneficial to use a vector instead of a static array.</p> <p>Some of the functions associated with a vector:</p> <p>begin(): Returns an iterator pointing to the first element in the vector.   end(): Returns an iterator pointing to the theoretical element that follows the last element in the vector.   rbegin(): Returns a reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element.  size(): Returns the number of elements in the vector. empty(): Returns whether the vector is empty.   push_back(): It pushes the elements into a vector from the back.   pop_back(): It is used to pop or remove elements from a vector from the back.   insert(): It inserts new elements before the element at the specified position.   </p> <p>vectorname.push_back(value) is the same as append in python. The method is declared inside the  and  header files."},{"location":"chapter2/#constructors-in-c","title":"Constructors in C++","text":"<p>Constructor is a member function of a class, whose name is the same as the class name. Constructor is a special type of member function that is used to initialize the data members for an object of a class automatically when an object of the same class is created. Constructor is invoked at the time of object creation. It constructs the values i.e. provides data for the object that is why it is known as a constructor. Constructors do not return value, hence they do not have a return type. A constructor gets called automatically when we create the object of the class.  </p> <p>Parameterized Constructors make it possible to pass arguments to constructors. Typically, these arguments help initialize an object when it is created. To create a parameterized constructor, simply add parameters to it the way you would to any other function. When you define the constructor\u2019s body, use the parameters to initialize the object.  </p> <p>The use of the initializer list : nodes(nodes) is a shorthand way of initializing the nodes member variable with the value passed as the parameter. It is a best practice to use initializer lists in constructors to initialize member variables, as it can improve performance and avoid unnecessary object copying.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point {\nprivate:\n    int x;\n    int y;\n\npublic:\n    Point(int i = 0, int j = 0): x(i), y(j) {}\n    /* The above use of Initializer list is optional as the\n        constructor can also be written as:\n        Point(int i = 0, int j = 0) {\n            x = i;\n            y = j;\n        }\n    */\n\n    int getX() const { return x; }\n    int getY() const { return y; }\n};\n\nint main()\n{\n    Point t1(10, 15);\n    cout &lt;&lt; \"x = \" &lt;&lt; t1.getX() &lt;&lt; \", \";\n    cout &lt;&lt; \"y = \" &lt;&lt; t1.getY();\n    return 0;\n}\n</code></pre> <p>Overall, this constructor allows you to create a Cell object by providing a std::vector of Vertices objects, and it initializes the nodes member variable with the provided value.</p>"},{"location":"chapter2/#code-to-compute-the-area-and-perimeter-of-a-single-vertex-model","title":"Code to compute the area and perimeter of a single vertex model","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nclass Vertices{\n    public:\n    // for a 2D cell (x,y) are the vertex coordinates\n    // these are members of the class\n    double x;\n    double y;\n\n    // constructor to initialize the vertices\n    Vertices(double x1, double y1)\n    {\n    x = x1;\n    y = y1;\n    }\n\n};\n\nclass Cell{\n    public:\n    // nodes is a vector of vertices\n    vector&lt;Vertices&gt;nodes;\n\n    // Shoelace's formula to calculate the area of the cell\n    double get_Area(){\n        // initialise area\n        double area = 0;\n        // loop through the vertices\n        for (int i = 0; i &lt; nodes.size(); i ++){\n            // area calculated using the Shoelace formula\n            area += nodes[i].x * nodes[(i+1) % nodes.size()].y - nodes[(i+1) % nodes.size()].x * nodes[i].y;\n        }\n        // area = abs(area) / 2;\n        // although it is intuitive to think area as positive, here this is not the case\n        area = area / 2;\n        return area;\n    }\n\n    double get_Perimeter(){\n        // initialise perimeter\n        double perimeter = 0;\n        // loop through the vertices\n        for (int i = 0; i &lt; nodes.size(); i++){\n            // find distance between vertices\n            double distance = sqrt(pow(nodes[i].x - nodes[(i+1) % nodes.size()].x, 2) + pow(nodes[i].y - nodes[(i+1) % nodes.size()].y, 2));\n            // add distance to perimeter\n            perimeter += distance;         \n        }\n        return perimeter;\n    }\n};\n// main function will create an object of the class Cell and calculate the area and perimeter\nint main(){\n    // declare an object of the class Cell\n    Cell C;\n    // assign vertices to the object\n    C.nodes = { {10, 7}, {5, 11}, {2, 8}, {2, 3},{5, 1}, {10, 4}};\n    // calculate the area\n    double area = C.get_Area();\n    // calculate the perimeter\n    double perimeter = C.get_Perimeter();\n    // print the area and perimeter\n    cout &lt;&lt; \"Area of the cell is: \" &lt;&lt; area &lt;&lt; endl;\n    cout &lt;&lt; \"Perimeter of the cell is: \" &lt;&lt; perimeter &lt;&lt; endl;\n    return 0;\n\n}\n</code></pre>"},{"location":"chapter2/#c-array","title":"C++ array","text":"<p>Suppose you want to store multiple values like \"orange\", \"apple\", \"watermelon\" to a single variable say \"fruit\". Then instead of declaring each of them separately as \"fruit1\", \"fruit2\", \"fruit3\" , we can make use of arrays. Arrays are used to store multiple values to a single variable, instead of declaring separate variable for each value.</p> <pre><code>string fruits[3] = {\"orange\", \"apple\", \"watermelon\"};\n\\\\ here 3 is the number of elements in the array\n</code></pre> <p>Access an element of array by referring to index number </p> <pre><code>cout &lt;&lt; fruits[1];\n\\\\ Output: apple\n</code></pre> <p>An element can be replaced using the index number too</p> <pre><code>fruits[1] = \"guava\";\ncout &lt;&lt; fruits[1];\n\\\\ Output: guava\n</code></pre>"},{"location":"chapter2/#cell-arrays","title":"Cell arrays","text":""},{"location":"chapter2/#c-pointers-and","title":"C++ pointers and &amp;","text":"<p>address (&amp;) assigns the address of the variable to another and pointer () assigns the value* of the variable to another.</p> <pre><code>   var = 3000;\n   // take the address of var\n   ptr = &amp;var;\n   // take the value available at ptr\n   val = *ptr;\n</code></pre> <p>https://www.freecodecamp.org/news/cpp-vector-how-to-initialize-a-vector-in-a-constructor/</p>"},{"location":"chapter2/#range-based-for-loop-in-c","title":"Range-based for loop in C++","text":"<p>Syntax : for ( init-statement(optional) range-declaration : range-expression ){ loop statement }</p> <p>auto specifier:  A placeholder type specifier designates a placeholder type that will be replaced later, typically by deduction from an initializer. The placeholder auto may be accompanied by modifiers, such as const or &amp;, which will participate in the type deduction. The placeholder decltype(auto) must be the sole constituent of the declared type</p> <p>An example of range based for loop:  </p> <pre><code>for (const auto&amp; vertex : nodes) {}\n</code></pre> <p>Reference: https://en.cppreference.com/w/cpp/language/range-for  https://en.cppreference.com/w/cpp/language/auto </p>"},{"location":"chapter2/#size_t","title":"size_t","text":"<p>A good rule of thumb is for anything that you need to compare in the loop condition against something that is naturally a std::size_t itself.</p> <p>std::size_t is the type of any sizeof expression and as is guaranteed to be able to express the maximum size of any object (including any array) in C++. By extension it is also guaranteed to be big enough for any array index so it is a natural type for a loop by index over an array.</p> <p>If you are just counting up to a number then it may be more natural to use either the type of the variable that holds that number or an int or unsigned int (if large enough) as these should be a natural size for the machine.</p> <p>size_t is the result type of the sizeof operator.</p> <p>Use size_t for variables that model size or index in an array. size_t conveys semantics: you immediately know it represents a size in bytes or an index, rather than just another integer.</p> <p>Also, using size_t to represent a size in bytes helps making the code portable.</p> <p>Reference: https://stackoverflow.com/questions/1951519/when-to-use-stdsize-t </p>"},{"location":"chapter2/#solving-the-problem-of-garbage-values-of-last-two-coordinates","title":"Solving the problem of garbage values of last two coordinates","text":"<p>The issue with the huge or unexpected values for the last coordinates likely stems from accessing elements outside the bounds of the basal_nodes and apical_nodes arrays. This is because the loop iterates from 0 to N-1, and for the last iteration (when i = N-1), the code attempts to access basal_nodes[i + 1] and apical_nodes[i + 1], which are out of bounds when i + 1 = N. Accessing elements outside the bounds of a vector in C++ leads to undefined behavior, which in this case manifests as garbage values being read.</p> <p>To fix this, you should ensure that the index wraps around to 0 when it reaches N, similar to how it's commented out in the code for the clockwise order of vertices. This can be achieved by using the modulo operator % with N to ensure the index stays within bounds.</p> <p>Here's the corrected part of the loop:</p> <pre><code>// Corrected loop to ensure indices are within bounds\nfor (int i = 0; i &lt; N; i++) {\n    vector&lt;Vertices&gt; nodes = {\n        // Ensure wrapping with modulo operation\n        apical_nodes[i], basal_nodes[i],\n        basal_nodes[(i + 1) % N], apical_nodes[(i + 1) % N]\n    };\n    cells.push_back(Cell(nodes));\n    // print the cell vertices\n    cout &lt;&lt; \"Cell \" &lt;&lt; i + 1 &lt;&lt; \" vertices: \";\n    for (const auto&amp; vertex : nodes) {\n        cout &lt;&lt; \"(\" &lt;&lt; vertex.x &lt;&lt; \", \" &lt;&lt; vertex.y &lt;&lt; \") \";\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre> <p>This change ensures that when i + 1 equals N, the index wraps around to 0, preventing out-of-bounds access and the resulting undefined behavior.</p>"}]}